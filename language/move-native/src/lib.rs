// Copyright (c) The Diem Core Contributors
// Copyright (c) The Move Contributors
// SPDX-License-Identifier: Apache-2.0

//! A Move native runtime prototype.
//!
//! This crate is part of the Solana project to port Move to LLVM and SBF.
//!
//! It contains three types of definitions
//!
//! - Types with layouts known to the compiler for the purposes of calling
//!   runtime functions. These have simple C-ABI layouts.
//! - "Native" library functions required by the Move standard library, calls to
//!   which are generated by the LLVM backend.
//! - Runtime functions specific to the LLVM port as necessary to dynamically
//!   implement Move semantics.
//!
//! As of now this crate is concerned only with implementing Move "natives"
//! required by the Move standard library. The basic strategy is to define
//! simple data types for primitives like scalars and vectors, and runtime types
//! like type descriptors; and naming and calling conventions for translating
//! Move native calls to C-ABI calls. The native implementations convert the
//! Move types to existing Rust types like `Vec` to do their work.
//!
//! It contains several modules dividing the crate by concerns:
//!
//! - `rt_types` defines the types shared between LLVM and the runtime.
//! - `rt` defines other runtime calls emitted by the compiler
//! - `std` defines the native functions called declared by Move `std`.
//! - `conv` defines conversions between Move types and Rust types.
//! - `target_defs` defines Solana-specific definitions that differ from Move VM
//!   or might reasonably differ for non-Solana targets.
//!
//!
//! # Native functions background
//!
//! Native functions in Move are functions that the standard library relies on
//! the runtime to provide. They are declared with the `native` keyword and no
//! implementation. They are similar to `extern` functions in Rust.
//!
//! Here are some examples:
//!
//! ```move
//!    native public fun sha2_256(data: vector<u8>): vector<u8>;
//!
//!    /// Add element `e` to the end of the vector `v`.
//!    native public fun push_back<Element>(v: &mut vector<Element>, e: Element);
//!
//!    /// Pop an element from the end of vector `v`.
//!    /// Aborts if `v` is empty.
//!    native public fun pop_back<Element>(v: &mut vector<Element>): Element;
//!
//!    /// Return the binary representation of `v` in BCS (Binary Canonical Serialization) format
//!    native public fun to_bytes<MoveValue>(v: &MoveValue): vector<u8>;
//! ```
//!
//! In the Move VM these are implemented in Rust and registered with the VM at
//! runtime. These implementations are tightly tied to VM internals, and include
//! features like gas accounting that are irrelevant for the LLVM port. They are
//! not directly reusable by the LLVM port at this time.
//!
//!
//! # Generics and type interpretation
//!
//! The translation between Move native declarations and the C ABI is relatively
//! straightforward, with conventions described further in this document.
//!
//! The big complication is that many natives are generic, so there are choices
//! to be made about how to interpret type descriptors.
//!
//! This implementation interprets types at runtime by passing a [`MoveType`]
//! reference for every generic type. The `MoveType` definition closely mirrors
//! the Move compiler's `runtime_type::Type` definition.
//!
//! It appears that the native calls mostly need to know about size and
//! alignment of types to implement things like generic vector operations. There
//! are though functions for serialization and debug printing that would appear
//! to require fully interpreting arbitrary Move types. It is not yet clear
//! what challenges this will entail.
//!
//! Embedding full type interpreters into the runtime means that every Move
//! program will contain code for interpreting every possible type, including
//! those it does not need. There may be ways to mitigate this bloat with clever
//! structure and LTO, but it is unclear.
//!
//! The alternative to runtime type interpretation is to have the compiler emit
//! monomorphizations of native calls. This would appear to be a challenging
//! problem, one that might be easiest solved by having the compiler emit Rust
//! code to instantiate generic natives. This approach could be left to a future
//! optimization.
//!
//!
//! # Reusing move crates and `no-std`
//!
//! For portability it could be desirable to not depend on `std`.
//!
//! It may be necessary to reuse existing move crates, which will force this
//! crate to depend on Rust `std`. For Solana this probably won't present a
//! problem as Solana has a mostly-complete port of `std`.
//!
//! Move serialization at least depends ot the [`bcs`] crate, which has relatively
//! few dependencies, but does depend on `std`. It could conceivably be adopted
//! to a `no-std` environment.
//!
//! This crate itself doesn't directly use `std`.
//!
//!
//! # Platform compatibility
//!
//! Some definitions are different on Solana than on Move VM.
//!
//! - An address is 32 bytes to match Solana pubkeys. On Move VM an address is
//!   16 bytes by default but can be configured as 20 or 32 bytes at compile
//!   time.
//!
//!
//! # Naming conventions
//!
//! Within the Move VM natives are identified by a module name plus a function
//! name, like "vector" + "push_back". They do not appear to additionally be
//! identified by a library name like "std".
//!
//! Our native symbol names are a concatenation of the prefix "move_native_",
//! plus the module name and function name. So the vector `push_back` function
//! symbol is
//!
//! > `move_native_vector_push_back`
//!
//! In Rust code, native functions are defined under the `std` module, in
//! submodules that mirror the module heirarchy of the Move standard library,
//! and their final symbol names are given through the `export_name` attribute.
//!
//! Runtime functions needed by the compiler are prefixed "move_rt_",
//! like `move_rt_abort`.
//!
//!
//! # Data types
//!
//! Data types known to both the compiler and the runtime are defined in [`rt_types`].
//! They are all declared with explicit `repr` attributes to have a defined layout that
//! is easy to codegen.
//!
//! The most important types for the compiler and the vector type,
//! [`MoveUntypedVector`] here, and the type descriptor, here [`MoveType`].
//!
//! `MoveType` is similar to `move_vm_types::runtime_types::Type`, but with a
//! structure that does not rely on Rust-specific type layout. `MoveType`
//! contains recursive `&'static` references to other `MoveType`s, necessitating
//! that binaries contain a static table of all needed type descriptors.
//!
//! Generic values are represented by references or pointers to [`AnyType`],
//! which is simply a transparent wrapper around a u8, pointers to which must
//! be unsafely casted based on an accompanying `MoveType`.
//!
//! Move references as interpreted by `TypeDesc` are assumed to always be
//! pointers - no fat pointers.
//!
//! The types defined in `rt_types` will change. The exact definitions will
//! depend on decisions made for code generation.
//!
//!
//! ## Vectors and strings
//!
//! Move vectors are operated on by casting to Rust vectors and reusing the Rust
//! methods. Move vectors have the same layout as Rust vecs, on the theory this
//! may save a few instructions during conversions.
//!
//! Move strings are a library type and not known to the Move compiler†.
//! They are a wrapper around byte vectors, and native string calls are
//! operations on `MoveByteVector`.
//!
//! Vectors must be allocated with the [`move_native_vec_empty`] and deallocated
//! with the [`move_native_vec_destroy_empty`] runtime calls.
//!
//! † - note that although `String` is a library type, the ASCII `String` (move
//! has UTF-8 and ASCII strings) is exposed to the runtime via the `TypeName`
//! library type, which is passed by value in the [`move_native_type_name_get`]
//! native function, the code generator and the runtime need to agree on its
//! layout.
//!
//!
//! ## Structs
//!
//! Structs are difficult for the runtime to handle. Since they have arbitrary
//! layout the runtime has to interpret them dynamically.
//!
//! The struct type descriptor specifies the struct's size, including
//! post-padding as needed for side-by-side layout in arrays, and its alignment;
//! and it specifies the types and offsets of every field.
//!
//! Requirements:
//!
//! - Size must be > 0
//! - Alignment must be > 0
//! - Alignment must be a power of 2
//! - Size rounded up to alignment must not overflow a pointer-sized signed integer
//!
//! Since the vector-of-struct code is necessarily very low level, not reusing
//! the actual Rust Vec methods, we may end up just doing the same for vecs of
//! all types. Super unsafe but more efficient than using typed Rust vectors.
//!
//!
//! # Calling conventions
//!
//! The calling conventions are straightforword, following the C ABI, with some
//! extra patterns necessary for things like Move type parameters and unsized
//! generic values.
//!
//! - type parameters
//!   - passed as `&MoveType`
//! - by-ref generic types
//!   - passed by `&AnyType`
//! - by-value generic types
//!   - passed by `*mut AnyType`
//!   - examples: `write_to_event_store`
//! - by-value generic return types
//!   - stack-allocated return pointer of `*mut AnyType`
//!   - examples: `pop_back`
//!
//!
//! # Drop-bombs
//!
//! `rt_types` that contain allocations also define `Drop` to panic. This
//! ensures that they are always destroyed by calling the correct runtime
//! function, which is helpful in test cases. It does complicate runtime code
//! that deals with these types though, because the runtime has to call
//! `mem::forget` on them at the right moments. These cases call the wrapper
//! function `disarm_drop_bomb` to make clear what is happening.
//!
//!
//! # Panic handling
//!
//! This crate does not handle panics at the FFI boundary. When used in a
//! runtime context it should be compiled such that panics trigger an abort.
//!
//! At this time it does not define its own panic handler, but probably will in
//! the future.
//!
//!
//! # References
//!
//! Useful Move code to read.
//!
//! - `move-stdlib::natives`
//! - `move-vm-types::loaded_data::Type`
//! - `move-vm-types::values::Value`
//! - `move-core-types::value`
//!
//!
//! # todo
//!
//! - type constraints
//!   - `write_to_event_store<T: drop + store>`
//!   - may not matter at runtime
//! - generic by-value and return arguments might instead be `&mut MaybeUninit<SomeUnsizedPlaceholder>`
//!   - llvm would need to write a fat pointer - do they have defined layout?
//! - should serialization maintain compatibility with move vm?
//! - add context to unwrapped errors
//! - vec_empty/destroy_empty can be implemented unsafely for all cases, is in the struct case
//! - _all_ vec ops for all cases can probably be implemented using an
//!   adaptation of the vector-of-struct case, at which point we probably don't
//!   even need to use Rust vecs at all, at the expense of some readability.
//! - struct serialize / debug don't include struct / field names
//! - add a full test suite
//! - make sure tests can be run under miri
//! - todo add drop-bombs to other rt_types with allocations
//! - remove transmutes to make the semantics clearer to miri?

#![allow(unused)]
#![no_std]

// NB Solana's Rust seems to allow use of unstable features.
// This wouldn't normally be allowed.
#![cfg_attr(feature = "solana", feature(default_alloc_error_handler))]

extern crate alloc;

/// Types known to the compiler.
pub(crate) mod rt_types {
    use crate::target_defs;

    /// A Move vector with an untyped buffer.
    ///
    /// Used in the API for generic vector arguments.
    ///
    /// The only way to interact with these is to convert them from / to Rust
    /// vectors or references to Rust vectors, with functions in the [`conv`]
    /// module.
    ///
    /// The only way to create and destroy them is with the
    /// [`move_native_vec_empty`] and [`move_native_vec_destroy_empty`] native
    /// calls.
    #[repr(C)]
    #[derive(Debug)]
    pub struct MoveUntypedVector {
        pub ptr: *mut u8,  // Safety: must be correctly aligned per type
        pub capacity: u64, // in typed elements, not u8
        pub length: u64,   // in typed elements, not u8
    }

    /// A Move vector of bytes.
    ///
    /// These occur in the API enough to warrant their own type, and there are
    /// dedicated functions to convert them to Rust vectors.
    #[repr(C)]
    pub struct MoveByteVector {
        pub ptr: *mut u8,
        pub capacity: u64,
        pub length: u64,
    }

    /// A Move vector of signers.
    ///
    /// This type occurs in the native API, but it will probably be removed, in
    /// favor of just using `MoveUntypedVector`.
    #[repr(C)]
    pub struct MoveSignerVector {
        pub ptr: *mut MoveSigner,
        pub capacity: u64,
        pub length: u64,
    }

    /// A reification of the Move runtime type description.
    ///
    /// This is structured as a `TypeDesc` indicating which type a thing is,
    /// and an undiscriminated union holding additional information about the
    /// type.
    ///
    /// cc runtime_types::Type
    ///
    /// # Safety
    ///
    /// The pointer must be to static memory and never mutated.
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct MoveType {
        pub name: StaticTypeName,
        pub type_desc: TypeDesc,
        pub type_info: *const TypeInfo,
    }

    impl core::fmt::Debug for MoveType {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            // fixme: implement this better
            unsafe {
                write!(f, "{}", self.name.as_ascii_str());
            }
            Ok(())
        }
    }

    /// # Safety
    ///
    /// The pointer must be to static memory and never mutated.
    #[repr(C)]
    #[derive(Copy, Clone, Debug)]
    pub struct StaticTypeName {
        pub ptr: *const u8,
        pub len: u64,
    }

    impl StaticTypeName {
        pub unsafe fn as_ascii_str<'a>(&'a self) -> &'a str {
            core::str::from_utf8_unchecked(core::slice::from_raw_parts(
                self.ptr,
                usize::try_from(self.len).expect("overflow"),
            ))
        }
    }

    static DUMMY_TYPE_NAME_SLICE: &[u8] = b"dummy";
    pub static DUMMY_TYPE_NAME: StaticTypeName = StaticTypeName {
        ptr: DUMMY_TYPE_NAME_SLICE as *const [u8] as *const u8,
        len: 5,
    };

    unsafe impl Sync for StaticTypeName {}

    #[repr(u32)]
    #[derive(Copy, Clone)]
    pub enum TypeDesc {
        Bool = 1,
        U8 = 2,
        U64 = 3,
        U128 = 4,
        Address = 5,
        Signer = 6,
        Vector = 7,
        Struct = 8,
        //StructInstantiation = 9,
        Reference = 10,
        //MutableReference = 11,
        //TyParam = 12,
    }

    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union TypeInfo {
        pub nothing: u8, // if no type info is needed
        pub vector: VectorTypeInfo,
        pub struct_: StructTypeInfo,
        pub struct_instantiation: u8, // todo
        pub reference: ReferenceTypeInfo,
        pub mutable_reference: ReferenceTypeInfo,
        pub ty_param: u8, // todo
    }

    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct VectorTypeInfo {
        pub element_type: &'static MoveType,
    }

    /// # Safety
    ///
    /// This type is `Sync` so that it can be declared statically. The value
    /// pointed to by `field_array_ptr` should not be mutated, or `Sync` will be
    /// violated.
    #[repr(C)]
    #[derive(Copy, Clone, Debug)]
    pub struct StructTypeInfo {
        /// Pointer to an array of field infos.
        ///
        /// This would ideally be a Rust static slice, but the layout is
        /// seemingly undefined.
        pub field_array_ptr: *const StructFieldInfo,
        pub field_array_len: u64,
        /// Size of the struct within an array.
        pub size: u64,
        /// Alignment of the struct.
        pub alignment: u64,
    }

    unsafe impl Sync for StructTypeInfo {}

    #[repr(C)]
    #[derive(Copy, Clone, Debug)]
    pub struct StructFieldInfo {
        pub type_: MoveType,
        /// Offset in bytes within the field.
        pub offset: u64,
    }

    #[repr(C)]
    #[derive(Copy, Clone, Debug)]
    pub struct ReferenceTypeInfo {
        pub element_type: &'static MoveType,
    }

    #[repr(transparent)]
    pub struct AnyValue(u8);

    #[repr(transparent)]
    #[derive(Debug, PartialEq)]
    pub struct MoveSigner(pub MoveAddress);

    /// A Move address.
    ///
    /// This is mapped to the address size of the target platform, and may
    /// differ from Move VM.
    #[repr(transparent)]
    #[derive(Debug, PartialEq)]
    pub struct MoveAddress(pub [u8; target_defs::ACCOUNT_ADDRESS_LENGTH]);

    // Defined in std::type_name; not a primitive.
    //
    // todo how is drop glue handled?
    #[repr(C)]
    pub struct TypeName {
        pub name: MoveAsciiString,
    }

    // Defined in std::ascii; not a primitive.
    //
    // todo how is drop glue handled?
    #[repr(C)]
    pub struct MoveAsciiString {
        pub bytes: MoveByteVector,
    }

    // todo this would be more correct with a lifetime attached
    #[repr(transparent)]
    #[derive(Debug)]
    pub struct MoveUntypedReference(pub *const AnyValue);

    mod drop_bomb {
        // fixme this is pretty awkward - this is intended to be a no-std crate
        #[cfg(test)]
        extern crate std;

        #[cfg(not(test))]
        pub fn run(name: &str) {
            panic!("forgot to destroy {}", name);
        }

        #[cfg(test)]
        pub fn run(name: &str) {
            if !std::thread::panicking() {
                panic!("forgot to destroy {}", name);
            } else {
                std::eprintln!("forgot to destroy {}", name);
            }
        }
    }

    // Drop-bomb. Catch errors in test cases.
    impl Drop for MoveUntypedVector {
        fn drop(&mut self) {
            drop_bomb::run("MoveUntypedVector");
        }
    }

    // Drop-bomb. Catch errors in test cases.
    impl Drop for MoveByteVector {
        fn drop(&mut self) {
            drop_bomb::run("MoveByteVector");
        }
    }

    // Drop-bomb. Catch errors in test cases.
    impl Drop for MoveSignerVector {
        fn drop(&mut self) {
            drop_bomb::run("MoveSignerVector");
        }
    }

    /// Don't run destructors.
    ///
    /// Some of these runtime types hold allocations, and need to be destroyed
    /// in specific ways. If they are not, then they panic. These types must be
    /// destroyed by calling `mem::forget`, for which this function is a
    /// synonym.
    pub fn disarm_drop_bomb<T>(v: T) {
        core::mem::forget(v)
    }
}

/// Runtime calls emitted by the compiler.
mod rt {
    #[export_name = "move_rt_abort"]
    fn abort(code: u64) -> ! {
        crate::target_defs::abort(code);
    }
}

/// Implementations of native calls for `std`.
mod std {
    mod bcs {
        use crate::conv::*;
        use crate::rt_types::*;

        /// Serialize any value.
        ///
        /// This is definitely not correct. Just a first pass.
        ///
        /// # References
        ///
        /// - `move-vm-types::values::Value`
        /// - `move-core-types::value`
        #[export_name = "move_native_bcs_to_bytes"]
        unsafe extern "C" fn to_bytes(type_v: &MoveType, v: &AnyValue) -> MoveByteVector {
            let v = borrow_move_value_as_rust_value(type_v, v);
            let s = todo!(); //bcs::to_bytes(&v).unwrap();
            rust_vec_to_move_byte_vec(s)
        }
    }

    // nursery
    mod debug {
        use crate::conv::*;
        use crate::rt_types::*;
        use crate::target_defs;
        use alloc::format;
        use alloc::string::String;
        use core::fmt::Write;

        #[export_name = "move_native_debug_print"]
        unsafe extern "C" fn print(type_x: &MoveType, x: &AnyValue) {
            let v = borrow_move_value_as_rust_value(type_x, x);
            target_defs::print_string(&format!("{:?}", v));
        }

        #[export_name = "move_native_print_stack_trace"]
        extern "C" fn print_stack_trace() {
            target_defs::print_stack_trace();
        }
    }

    // nursery
    mod event {
        use crate::rt_types::*;

        #[export_name = "move_native_event_write_to_event_store"]
        unsafe extern "C" fn write_to_event_store(
            type_msg: &MoveType,
            guid: MoveByteVector,
            count: u64,
            msg: *mut AnyValue,
        ) {
            todo!()
        }
    }

    mod hash {
        use crate::conv::{move_byte_vec_to_rust_vec, rust_vec_to_move_byte_vec};
        use crate::rt_types::*;
        use sha2::{Digest, Sha256};
        use sha3::Sha3_256;

        #[export_name = "move_native_hash_sha2_256"]
        unsafe extern "C" fn sha2_256(ptr: MoveByteVector) -> MoveByteVector {
            let rust_vec = move_byte_vec_to_rust_vec(ptr);

            let hash_vec = Sha256::digest(rust_vec.as_slice()).to_vec();
            let move_vec = rust_vec_to_move_byte_vec(hash_vec);

            move_vec
        }

        #[export_name = "move_native_hash_sha3_256"]
        unsafe extern "C" fn sha3_256(ptr: MoveByteVector) -> MoveByteVector {
            todo!();
            let rust_vec = move_byte_vec_to_rust_vec(ptr);

            let hash_vec = Sha3_256::digest(rust_vec.as_slice()).to_vec();
            let move_vec = rust_vec_to_move_byte_vec(hash_vec);

            move_vec
        }
    }

    mod signer {
        use crate::rt_types::*;

        #[export_name = "move_native_signer_borrow_address"]
        extern "C" fn borrow_address(s: &MoveSigner) -> &MoveAddress {
            &s.0
        }
    }

    pub(crate) mod string {
        use crate::conv::*;
        use crate::rt_types::*;
        use alloc::vec::Vec;
        use core::str;

        #[export_name = "move_native_string_internal_check_utf8"]
        pub unsafe extern "C" fn internal_check_utf8(v: &MoveByteVector) -> bool {
            let rust_vec = borrow_move_byte_vec_as_rust_vec(v);
            let res = str::from_utf8(&rust_vec);

            match res {
                Ok(_) => true,
                Err(_) => false,
            }
        }

        #[export_name = "move_native_string_internal_is_char_boundary"]
        pub unsafe extern "C" fn internal_is_char_boundary(v: &MoveByteVector, i: u64) -> bool {
            let rust_vec = borrow_move_byte_vec_as_rust_vec(v);
            let i = usize::try_from(i).expect("usize");

            let rust_str = str::from_utf8(&rust_vec).expect("invalid utf8");
            rust_str.is_char_boundary(i)
        }

        #[export_name = "move_native_string_internal_sub_string"]
        pub unsafe extern "C" fn internal_sub_string(
            v: &MoveByteVector,
            i: u64,
            j: u64,
        ) -> MoveByteVector {
            let rust_vec = borrow_move_byte_vec_as_rust_vec(v);
            let i = usize::try_from(i).expect("usize");
            let j = usize::try_from(j).expect("usize");

            let rust_str = str::from_utf8(&rust_vec).expect("invalid utf8");

            let sub_rust_vec = rust_str[i..j].as_bytes().to_vec();
            rust_vec_to_move_byte_vec(sub_rust_vec)
        }

        #[export_name = "move_native_string_internal_index_of"]
        pub unsafe extern "C" fn internal_index_of(s: &MoveByteVector, r: &MoveByteVector) -> u64 {
            let s_rust_vec = borrow_move_byte_vec_as_rust_vec(s);
            let s_rust_str = str::from_utf8(&s_rust_vec).expect("invalid utf8");
            let r_rust_vec = borrow_move_byte_vec_as_rust_vec(r);
            let r_rust_str = str::from_utf8(&r_rust_vec).expect("invalid utf8");

            let res = s_rust_str.find(r_rust_str);

            u64::try_from(match res {
                Some(i) => i,
                None => s_rust_str.len(),
            })
            .expect("u64")
        }
    }

    mod type_name {
        use crate::conv::*;
        use crate::rt_types::*;

        #[export_name = "move_native_type_name_get"]
        unsafe extern "C" fn get(type_: &MoveType) -> TypeName {
            let name_slice = type_.name.as_ascii_str();
            let byte_type = MoveType {
                name: DUMMY_TYPE_NAME,
                type_desc: TypeDesc::U8,
                type_info: TypeInfo { nothing: 0 },
            };
            let mut byte_vector = super::vector::empty(&byte_type);
            {
                let mut rust_byte_vector = borrow_move_vec_as_rust_vec_mut::<u8>(&mut byte_vector);
                rust_byte_vector.reserve_exact(name_slice.len());
                for byte in name_slice.bytes() {
                    rust_byte_vector.push(byte);
                }
            }
            TypeName {
                name: MoveAsciiString {
                    // safety: MoveUntypedVector and MoveByteVector have the same representation
                    bytes: core::mem::transmute::<MoveUntypedVector, MoveByteVector>(byte_vector),
                },
            }
        }
    }

    mod unit_test {
        use crate::rt_types::*;

        #[export_name = "move_native_unit_test_create_signers_for_testing"]
        extern "C" fn create_signers_for_testing(num_signers: u64) -> MoveSignerVector {
            todo!()
        }
    }

    pub(crate) mod vector {
        use crate::conv::*;
        use crate::rt_types::*;
        use alloc::vec::Vec;
        use core::{mem, ptr};

        // Safety: Even empty Rust vectors have non-null buffer pointers,
        // which must be correctly aligned. This function crates empty Rust vecs
        // of the correct type and converts them to untyped move vecs.
        #[export_name = "move_native_vector_empty"]
        pub extern "C" fn empty(type_r: &MoveType) -> MoveUntypedVector {
            let move_vec = match type_r.type_desc {
                TypeDesc::Bool => rust_vec_to_move_vec::<bool>(Vec::new()),
                TypeDesc::U8 => rust_vec_to_move_vec::<u8>(Vec::new()),
                TypeDesc::U64 => rust_vec_to_move_vec::<u64>(Vec::new()),
                TypeDesc::U128 => rust_vec_to_move_vec::<u128>(Vec::new()),
                TypeDesc::Address => rust_vec_to_move_vec::<MoveAddress>(Vec::new()),
                TypeDesc::Signer => rust_vec_to_move_vec::<MoveSigner>(Vec::new()),
                TypeDesc::Vector => {
                    // Safety: need correct alignment for the internal vector
                    // pointer of the outer vector, which is non-null even for
                    // an unallocated vector. `MoveUntypedVector` has the same
                    // size and alignment regardless of the type it contains, so
                    // no need to interpret the vector type.
                    rust_vec_to_move_vec::<MoveUntypedVector>(Vec::new())
                }
                TypeDesc::Struct => unsafe {
                    // Safety: this gets pretty sketchy, and relies on internal
                    // Vec details that probably are not guaranteed. The most
                    // _correct_ way to initialize a Vec is to call its
                    // constructor.
                    //
                    // That is pretty tough with a type of any dynamically sized
                    // layout, so we're going to munge the pointers ourselves.
                    //
                    // The critical thing to know about Vec's pointers is:
                    //
                    // - They must always be aligned correctly
                    // - They are _never_ 0, even for empty Vec's, to allow null
                    //   pointer optimizations.
                    //
                    // Vec uses `NonNull::dangling` to create invalid non-null
                    // pointers, but that requires a concrete type of the
                    // correct alignment. We dig even deeper and use
                    // `ptr::invalid_mut`, which is an unstable function from
                    // the pointer provenance project. As it is unstable we just
                    // duplicate it in our `conv` module until it becomes
                    // stable.
                    //
                    // This should be the only location in this crate where we
                    // need to fabricate a pointer from an integer.
                    let size = type_r.type_info.struct_.size;
                    let size = usize::try_from(size).expect("overflow");
                    let alignment = type_r.type_info.struct_.alignment;
                    let alignment = usize::try_from(alignment).expect("overflow");

                    assert!(size != 0); // can't handle ZSTs
                    assert!(alignment != 0); // must have alignment
                    assert!(alignment.is_power_of_two());

                    let ptr = invalid_mut::<u8>(alignment);
                    MoveUntypedVector {
                        ptr,
                        capacity: 0,
                        length: 0,
                    }
                },
                TypeDesc::Reference => rust_vec_to_move_vec::<MoveUntypedReference>(Vec::new()),
            };

            move_vec
        }

        #[export_name = "move_native_vector_length"]
        pub unsafe extern "C" fn length(type_ve: &MoveType, v: &MoveUntypedVector) -> u64 {
            // It is not strictly necessary to convert the vec for this op.
            // Doing it for consistency.
            let rust_vec = borrow_typed_move_vec_as_rust_vec(type_ve, v);

            let len = match rust_vec {
                TypedMoveBorrowedRustVec::Bool(v) => v.len(),
                TypedMoveBorrowedRustVec::U8(v) => v.len(),
                TypedMoveBorrowedRustVec::U64(v) => v.len(),
                TypedMoveBorrowedRustVec::U128(v) => v.len(),
                TypedMoveBorrowedRustVec::Address(v) => v.len(),
                TypedMoveBorrowedRustVec::Signer(v) => v.len(),
                TypedMoveBorrowedRustVec::Vector(_t, v) => v.len(),
                TypedMoveBorrowedRustVec::Struct(s) => {
                    usize::try_from(s.inner.length).expect("overflow")
                }
                TypedMoveBorrowedRustVec::Reference(_t, v) => v.len(),
            };

            u64::try_from(len).expect("u64")
        }

        #[export_name = "move_native_vector_borrow"]
        unsafe extern "C" fn borrow<'v>(
            type_ve: &'v MoveType,
            v: &'v MoveUntypedVector,
            i: u64,
        ) -> &'v AnyValue {
            let rust_vec = borrow_typed_move_vec_as_rust_vec(type_ve, v);

            let i = usize::try_from(i).expect("usize");
            let value = match rust_vec {
                TypedMoveBorrowedRustVec::Bool(v) => mem::transmute(&v[i]),
                TypedMoveBorrowedRustVec::U8(v) => mem::transmute(&v[i]),
                TypedMoveBorrowedRustVec::U64(v) => mem::transmute(&v[i]),
                TypedMoveBorrowedRustVec::U128(v) => mem::transmute(&v[i]),
                TypedMoveBorrowedRustVec::Address(v) => mem::transmute(&v[i]),
                TypedMoveBorrowedRustVec::Signer(v) => mem::transmute(&v[i]),
                TypedMoveBorrowedRustVec::Vector(_t, v) => mem::transmute(&v[i]),
                TypedMoveBorrowedRustVec::Struct(s) => s.get(i),
                TypedMoveBorrowedRustVec::Reference(_t, v) => mem::transmute(&v[i]),
            };

            value
        }

        #[rustfmt::skip]
        #[export_name = "move_native_vector_push_back"]
        pub unsafe extern "C" fn push_back(
            type_ve: &MoveType,
            v: &mut MoveUntypedVector,
            e: *mut AnyValue
        ) {
            let mut rust_vec = borrow_typed_move_vec_as_rust_vec_mut(type_ve, v);

            match rust_vec {
                TypedMoveBorrowedRustVecMut::Bool(mut v) => v.push(ptr::read(e as *const bool)),
                TypedMoveBorrowedRustVecMut::U8(mut v) => v.push(ptr::read(e as *const u8)),
                TypedMoveBorrowedRustVecMut::U64(mut v) => v.push(ptr::read(e as *const u64)),
                TypedMoveBorrowedRustVecMut::U128(mut v) => v.push(ptr::read(e as *const u128)),
                TypedMoveBorrowedRustVecMut::Address(mut v) => v.push(ptr::read(e as *const MoveAddress)),
                TypedMoveBorrowedRustVecMut::Signer(mut v) => v.push(ptr::read(e as *const MoveSigner)),
                TypedMoveBorrowedRustVecMut::Vector(_t, mut v) => v.push(ptr::read(e as *const MoveUntypedVector)),
                TypedMoveBorrowedRustVecMut::Struct(mut s) => s.push(e),
                TypedMoveBorrowedRustVecMut::Reference(_t, mut v) => v.push(ptr::read(e as *const MoveUntypedReference)),
            }
        }

        #[rustfmt::skip]
        #[export_name = "move_native_vector_borrow_mut"]
        unsafe extern "C" fn borrow_mut<'v>(
            type_ve: &'v MoveType,
            v: &'v mut MoveUntypedVector,
            i: u64
        ) -> &'v mut AnyValue {
            let mut rust_vec = borrow_typed_move_vec_as_rust_vec_mut(type_ve, v);

            let i = usize::try_from(i).expect("usize");
            let value = match rust_vec {
                TypedMoveBorrowedRustVecMut::Bool(mut v) => mem::transmute(&mut v[i]),
                TypedMoveBorrowedRustVecMut::U8(mut v) => mem::transmute(&mut v[i]),
                TypedMoveBorrowedRustVecMut::U64(mut v) => mem::transmute(&mut v[i]),
                TypedMoveBorrowedRustVecMut::U128(mut v) => mem::transmute(&mut v[i]),
                TypedMoveBorrowedRustVecMut::Address(mut v) => mem::transmute(&mut v[i]),
                TypedMoveBorrowedRustVecMut::Signer(mut v) => mem::transmute(&mut v[i]),
                TypedMoveBorrowedRustVecMut::Vector(_t, mut v) => mem::transmute(&mut v[i]),
                TypedMoveBorrowedRustVecMut::Struct(mut s) => s.get_mut(i),
                TypedMoveBorrowedRustVecMut::Reference(_t, mut v) => mem::transmute(&mut v[i]),
            };

            value
        }

        #[export_name = "move_native_vector_pop_back"]
        pub unsafe extern "C" fn pop_back(
            type_ve: &MoveType,
            v: &mut MoveUntypedVector,
            r: *mut AnyValue,
        ) {
            let mut rust_vec = borrow_typed_move_vec_as_rust_vec_mut(type_ve, v);

            let msg = "popping from empty vec";
            match rust_vec {
                TypedMoveBorrowedRustVecMut::Bool(mut v) => {
                    ptr::write(r as *mut bool, v.pop().expect(msg));
                }
                TypedMoveBorrowedRustVecMut::U8(mut v) => {
                    ptr::write(r as *mut u8, v.pop().expect(msg));
                }
                TypedMoveBorrowedRustVecMut::U64(mut v) => {
                    ptr::write(r as *mut u64, v.pop().expect(msg));
                }
                TypedMoveBorrowedRustVecMut::U128(mut v) => {
                    ptr::write(r as *mut u128, v.pop().expect(msg));
                }
                TypedMoveBorrowedRustVecMut::Address(mut v) => {
                    ptr::write(r as *mut MoveAddress, v.pop().expect(msg));
                }
                TypedMoveBorrowedRustVecMut::Signer(mut v) => {
                    ptr::write(r as *mut MoveSigner, v.pop().expect(msg));
                }
                TypedMoveBorrowedRustVecMut::Vector(_t, mut v) => {
                    ptr::write(r as *mut MoveUntypedVector, v.pop().expect(msg));
                }
                TypedMoveBorrowedRustVecMut::Struct(mut s) => s.pop_into(r),
                TypedMoveBorrowedRustVecMut::Reference(_t, mut v) => {
                    ptr::write(r as *mut MoveUntypedReference, v.pop().expect(msg));
                }
            }
        }

        #[export_name = "move_native_vector_destroy_empty"]
        pub unsafe extern "C" fn destroy_empty(type_ve: &MoveType, v: MoveUntypedVector) {
            assert_eq!(v.length, 0);
            match type_ve.type_desc {
                TypeDesc::Bool => drop(move_vec_to_rust_vec::<bool>(v)),
                TypeDesc::U8 => drop(move_vec_to_rust_vec::<u8>(v)),
                TypeDesc::U64 => drop(move_vec_to_rust_vec::<u64>(v)),
                TypeDesc::U128 => drop(move_vec_to_rust_vec::<u128>(v)),
                TypeDesc::Address => drop(move_vec_to_rust_vec::<MoveAddress>(v)),
                TypeDesc::Signer => drop(move_vec_to_rust_vec::<MoveSigner>(v)),
                TypeDesc::Vector => {
                    // Safety: need the correct internal pointer alignment to
                    // deallocate; need the outer vector to be empty to avoid
                    // dropping the inner vectors. As in `empty`,
                    // MoveUntypedVector should have the same size/alignment
                    // regardless of the contained type, so no need to interpret
                    // the vector type.
                    drop(move_vec_to_rust_vec::<MoveUntypedVector>(v))
                }
                TypeDesc::Struct => {
                    // Safety: like in `empty` we want to deallocate here without
                    // creating a `Vec` of a concrete type, since handling the
                    // alignment would requiring enumerating many types.
                    //
                    // So here we're just going to free the pointer ourselves,
                    // constructing a correct `Layout` value to pass to the
                    // allocator.
                    //
                    // Note that this function can only be called on empty vecs,
                    // so we don't need to care about dropping elements.

                    let size = type_ve.type_info.struct_.size;
                    let size = usize::try_from(size).expect("overflow");
                    let alignment = type_ve.type_info.struct_.alignment;
                    let alignment = usize::try_from(alignment).expect("overflow");
                    let capacity = usize::try_from(v.capacity).expect("overflow");

                    assert!(size != 0); // can't handle ZSTs

                    if capacity != 0 {
                        let vec_byte_size = capacity.checked_mul(size).expect("overflow");
                        let layout =
                            alloc::alloc::Layout::from_size_align(vec_byte_size, alignment)
                                .expect("bad size or alignment");
                        alloc::alloc::dealloc(v.ptr, layout);
                    }

                    disarm_drop_bomb(v);
                }
                TypeDesc::Reference => drop(move_vec_to_rust_vec::<MoveUntypedReference>(v)),
            }
        }

        #[export_name = "move_native_vector_swap"]
        unsafe extern "C" fn swap(type_ve: &MoveType, v: &mut MoveUntypedVector, i: u64, j: u64) {
            let i = usize::try_from(i).expect("usize");
            let j = usize::try_from(j).expect("usize");

            let mut rust_vec = borrow_typed_move_vec_as_rust_vec_mut(type_ve, v);

            match rust_vec {
                TypedMoveBorrowedRustVecMut::Bool(mut v) => v.swap(i, j),
                TypedMoveBorrowedRustVecMut::U8(mut v) => v.swap(i, j),
                TypedMoveBorrowedRustVecMut::U64(mut v) => v.swap(i, j),
                TypedMoveBorrowedRustVecMut::U128(mut v) => v.swap(i, j),
                TypedMoveBorrowedRustVecMut::Address(mut v) => v.swap(i, j),
                TypedMoveBorrowedRustVecMut::Signer(mut v) => v.swap(i, j),
                TypedMoveBorrowedRustVecMut::Vector(_t, mut v) => v.swap(i, j),
                TypedMoveBorrowedRustVecMut::Struct(mut v) => v.swap(i, j),
                TypedMoveBorrowedRustVecMut::Reference(_t, mut v) => v.swap(i, j),
            }
        }
    }
}

/// Conversion from move types to rust types.
pub(crate) mod conv {
    use crate::rt_types::*;
    use alloc::vec::Vec;
    use core::marker::PhantomData;
    use core::mem;
    use core::ops::{Deref, DerefMut};
    use core::ptr;
    use core::slice;

    /// This is a placeholder for the unstable `ptr::invalid_mut`.
    ///
    /// It is a potential future way to create invalid pointers, which is
    /// required for correctly initializing empty vectors.
    ///
    /// This crate initializes empty vectors knowing only the alignment of their
    /// elements, but not the full type.
    pub const fn invalid_mut<T>(addr: usize) -> *mut T {
        // FIXME(strict_provenance_magic): I am magic and should be a compiler intrinsic.
        // We use transmute rather than a cast so tools like Miri can tell that this
        // is *not* the same as from_exposed_addr.
        // SAFETY: every valid integer is also a valid pointer (as long as you don't dereference that
        // pointer).
        unsafe { mem::transmute(addr) }
    }

    pub unsafe fn move_byte_vec_to_rust_vec(mv: MoveByteVector) -> Vec<u8> {
        let ret = MoveUntypedVector {
            ptr: mv.ptr,
            capacity: mv.capacity,
            length: mv.length,
        };
        disarm_drop_bomb(mv);
        move_vec_to_rust_vec(ret)
    }

    pub fn rust_vec_to_move_byte_vec(rv: Vec<u8>) -> MoveByteVector {
        let mv = rust_vec_to_move_vec(rv);
        let r = MoveByteVector {
            ptr: mv.ptr,
            capacity: mv.capacity,
            length: mv.length,
        };
        disarm_drop_bomb(mv);
        r
    }

    pub fn borrow_move_byte_vec_as_rust_vec<'mv>(
        mv: &'mv MoveByteVector,
    ) -> MoveBorrowedRustVec<'mv, u8> {
        assert_eq!(
            mem::size_of::<MoveByteVector>(),
            mem::size_of::<MoveUntypedVector>()
        );
        assert_eq!(
            mem::align_of::<MoveByteVector>(),
            mem::align_of::<MoveUntypedVector>()
        );
        // Safety: both repr(c) with same layout, probably ok
        let mv: &'mv MoveUntypedVector = unsafe { mem::transmute(mv) };
        unsafe { borrow_move_vec_as_rust_vec(mv) }
    }

    pub unsafe fn move_vec_to_rust_vec<T>(mv: MoveUntypedVector) -> Vec<T> {
        let rv = Vec::from_raw_parts(
            mv.ptr as *mut T,
            usize::try_from(mv.length).expect("overflow"),
            usize::try_from(mv.capacity).expect("overflow"),
        );
        disarm_drop_bomb(mv);
        rv
    }

    pub fn rust_vec_to_move_vec<T>(mut rv: Vec<T>) -> MoveUntypedVector {
        let mv = MoveUntypedVector {
            ptr: rv.as_mut_ptr() as *mut u8,
            capacity: u64::try_from(rv.capacity()).expect("overflow"),
            length: u64::try_from(rv.len()).expect("overflow"),
        };
        mem::forget(rv);
        mv
    }

    pub unsafe fn borrow_move_vec_as_rust_vec<'mv, T>(
        mv: &'mv MoveUntypedVector,
    ) -> MoveBorrowedRustVec<'mv, T> {
        let rv = Vec::from_raw_parts(
            mv.ptr as *mut T,
            usize::try_from(mv.length).expect("overflow"),
            usize::try_from(mv.capacity).expect("overflow"),
        );
        MoveBorrowedRustVec {
            inner: rv,
            _lifetime: PhantomData,
        }
    }

    pub unsafe fn borrow_move_vec_as_rust_vec_mut<'mv, T>(
        mv: &'mv mut MoveUntypedVector,
    ) -> MoveBorrowedRustVecMut<'mv, T> {
        let rv = Vec::from_raw_parts(
            mv.ptr as *mut T,
            usize::try_from(mv.length).expect("overflow"),
            usize::try_from(mv.capacity).expect("overflow"),
        );
        MoveBorrowedRustVecMut {
            inner: rv,
            original: mv,
        }
    }

    pub struct MoveBorrowedRustVec<'mv, T> {
        inner: Vec<T>,
        _lifetime: PhantomData<&'mv ()>,
    }

    #[derive(Debug)]
    pub struct MoveBorrowedRustVecMut<'mv, T> {
        inner: Vec<T>,
        original: &'mv mut MoveUntypedVector,
    }

    impl<'mv, T> Drop for MoveBorrowedRustVec<'mv, T> {
        fn drop(&mut self) {
            let rv = mem::replace(&mut self.inner, Vec::new());
            mem::forget(rv);
        }
    }

    impl<'mv, T> Drop for MoveBorrowedRustVecMut<'mv, T> {
        fn drop(&mut self) {
            let mut rv = mem::replace(&mut self.inner, Vec::new());

            self.original.length = u64::try_from(rv.len()).expect("overflow");
            self.original.capacity = u64::try_from(rv.capacity()).expect("overflow");
            self.original.ptr = rv.as_mut_ptr() as *mut u8;

            mem::forget(rv);
        }
    }

    impl<'mv, T> Deref for MoveBorrowedRustVec<'mv, T> {
        type Target = Vec<T>;

        fn deref(&self) -> &Self::Target {
            &self.inner
        }
    }

    impl<'mv, T> Deref for MoveBorrowedRustVecMut<'mv, T> {
        type Target = Vec<T>;

        fn deref(&self) -> &Self::Target {
            &self.inner
        }
    }

    impl<'mv, T> DerefMut for MoveBorrowedRustVecMut<'mv, T> {
        fn deref_mut(&mut self) -> &mut Self::Target {
            &mut self.inner
        }
    }

    /// A vector of Move structs.
    ///
    /// Since we can't instantiate Move structs as Rust structs, this is a
    /// container that unsafely implements exactly the ops needed to deal with
    /// Move's `vector<T>`.
    #[derive(Debug)]
    pub struct MoveBorrowedRustVecOfStruct<'mv> {
        pub inner: &'mv MoveUntypedVector,
        pub name: StaticTypeName,
        pub type_: &'mv StructTypeInfo,
    }

    #[derive(Debug)]
    pub struct MoveBorrowedRustVecOfStructMut<'mv> {
        pub inner: &'mv mut MoveUntypedVector,
        pub name: StaticTypeName,
        pub type_: &'mv StructTypeInfo,
    }

    impl<'mv> MoveBorrowedRustVecOfStruct<'mv> {
        pub unsafe fn iter<'s>(&'s self) -> impl Iterator<Item = &'s AnyValue> {
            let struct_size = usize::try_from(self.type_.size).expect("overflow");
            let vec_len = usize::try_from(self.inner.length).expect("overflow");
            (0..vec_len).map(move |i| {
                let base_ptr = self.inner.ptr;
                let offset = i.checked_mul(struct_size).expect("overflow");
                let offset = isize::try_from(offset).expect("overflow");
                let element_ptr = base_ptr.offset(offset);
                let element_ref = &*(element_ptr as *const AnyValue);
                element_ref
            })
        }

        pub unsafe fn get(&self, i: usize) -> &'mv AnyValue {
            let struct_size = usize::try_from(self.type_.size).expect("overflow");
            let vec_len = usize::try_from(self.inner.length).expect("overflow");

            if i >= vec_len {
                panic!("index out of bounds");
            }

            let base_ptr = self.inner.ptr;
            let offset = i.checked_mul(struct_size).expect("overflow");
            let offset = isize::try_from(offset).expect("overflow");
            let element_ptr = base_ptr.offset(offset);
            let element_ref = &*(element_ptr as *const AnyValue);
            element_ref
        }
    }

    impl<'mv> MoveBorrowedRustVecOfStructMut<'mv> {
        pub unsafe fn get_mut(&mut self, i: usize) -> &'mv mut AnyValue {
            let struct_size = usize::try_from(self.type_.size).expect("overflow");
            let vec_len = usize::try_from(self.inner.length).expect("overflow");

            if i >= vec_len {
                panic!("index out of bounds");
            }

            let base_ptr = self.inner.ptr;
            let offset = i.checked_mul(struct_size).expect("overflow");
            let offset = isize::try_from(offset).expect("overflow");
            let element_ptr = base_ptr.offset(offset);
            let element_ref = &mut *(element_ptr as *mut AnyValue);
            element_ref
        }

        pub unsafe fn push(&mut self, ptr: *mut AnyValue) {
            self.maybe_grow();

            let struct_size = usize::try_from(self.type_.size).expect("overflow");
            let vec_len = usize::try_from(self.inner.length).expect("overflow");
            let vec_cap = usize::try_from(self.inner.capacity).expect("overflow");

            assert!(vec_len < vec_cap);

            let i = vec_len;

            let base_ptr = self.inner.ptr;
            let offset = i.checked_mul(struct_size).expect("overflow");
            let offset = isize::try_from(offset).expect("overflow");
            let element_ptr = base_ptr.offset(offset);

            let src_ptr = ptr as *mut u8;
            ptr::copy_nonoverlapping(src_ptr, element_ptr, struct_size);

            self.inner.length = self.inner.length.checked_add(1).expect("overflow");
        }

        pub unsafe fn maybe_grow(&mut self) {
            let struct_size = usize::try_from(self.type_.size).expect("overflow");
            let vec_len = usize::try_from(self.inner.length).expect("overflow");
            let vec_cap = usize::try_from(self.inner.capacity).expect("overflow");

            if vec_len < vec_cap {
                return;
            }

            assert_eq!(vec_len, vec_cap);

            self.grow_amortized();
        }

        /// This is approximately like `RawVec::grow_amortized`.
        ///
        /// With no `reserve_exact` feature in Move, this always produces
        /// power-of-two capacity.
        #[cold]
        pub unsafe fn grow_amortized(&mut self) {
            let struct_size = usize::try_from(self.type_.size).expect("overflow");
            let struct_align = usize::try_from(self.type_.alignment).expect("overflow");
            let vec_len = usize::try_from(self.inner.length).expect("overflow");
            let vec_cap = usize::try_from(self.inner.capacity).expect("overflow");

            assert!(struct_size != 0); // can't handle ZSTs
            assert_eq!(vec_len, vec_cap);

            // Same as RawVec
            let min_non_zero_cap = if struct_size == 1 {
                8
            } else if struct_size <= 1024 {
                4
            } else {
                1
            };

            let new_cap = vec_cap.checked_mul(2).expect("overflow");
            let new_cap = core::cmp::max(new_cap, min_non_zero_cap);
            let new_cap_u64 = u64::try_from(new_cap).expect("overflow");

            let old_vec_byte_size = vec_cap.checked_mul(struct_size).expect("overflow");
            let new_vec_byte_size = new_cap.checked_mul(struct_size).expect("overflow");
            let new_layout = alloc::alloc::Layout::from_size_align(new_vec_byte_size, struct_align)
                .expect("bad size or alignment");

            if vec_cap == 0 {
                let new_ptr = alloc::alloc::alloc(new_layout);
                if new_ptr.is_null() {
                    alloc::alloc::handle_alloc_error(new_layout);
                }
                self.inner.ptr = new_ptr;
                self.inner.capacity = new_cap_u64;
            } else {
                let old_layout =
                    alloc::alloc::Layout::from_size_align(old_vec_byte_size, struct_align)
                        .expect("bad size or alignment");

                let new_ptr = alloc::alloc::realloc(self.inner.ptr, old_layout, new_vec_byte_size);
                if new_ptr.is_null() {
                    alloc::alloc::handle_alloc_error(new_layout);
                }
                self.inner.ptr = new_ptr;
                self.inner.capacity = new_cap_u64;
            }
        }

        pub unsafe fn pop_into(&mut self, ptr: *mut AnyValue) {
            let struct_size = usize::try_from(self.type_.size).expect("overflow");
            let vec_len = usize::try_from(self.inner.length).expect("overflow");

            let i = vec_len.checked_sub(1).expect("popping empty vector");

            let base_ptr = self.inner.ptr;
            let offset = i.checked_mul(struct_size).expect("overflow");
            let offset = isize::try_from(offset).expect("overflow");
            let element_ptr = base_ptr.offset(offset);

            let dest_ptr = ptr as *mut u8;
            ptr::copy_nonoverlapping(element_ptr, dest_ptr, struct_size);

            self.inner.length = self.inner.length.checked_sub(1).expect("overflow");
        }

        pub unsafe fn swap(&mut self, i: usize, j: usize) {
            let struct_size = usize::try_from(self.type_.size).expect("overflow");
            let vec_len = usize::try_from(self.inner.length).expect("overflow");

            if i >= vec_len || j >= vec_len {
                panic!("index out of bounds");
            }

            // Safety: must avoid overlapping pointers in swap_nonoverlapping
            // below.
            if i == j {
                return;
            }

            let base_ptr = self.inner.ptr;

            let i_offset = i.checked_mul(struct_size).expect("overflow");
            let i_offset = isize::try_from(i_offset).expect("overflow");
            let i_element_ptr = base_ptr.offset(i_offset);
            let j_offset = j.checked_mul(struct_size).expect("overflow");
            let j_offset = isize::try_from(j_offset).expect("overflow");
            let j_element_ptr = base_ptr.offset(j_offset);

            // Safety: because of the presense of uninitialized padding bytes,
            // we must (I think) do this swap with raw pointers, not slices.
            ptr::swap_nonoverlapping(i_element_ptr, j_element_ptr, struct_size);
        }
    }

    pub enum BorrowedTypedMoveValue<'mv> {
        Bool(&'mv bool),
        U8(&'mv u8),
        U64(&'mv u64),
        U128(&'mv u128),
        Address(&'mv MoveAddress),
        Signer(&'mv MoveSigner),
        Vector(MoveType, &'mv MoveUntypedVector),
        Struct(StructTypeInfo, &'mv AnyValue),
        Reference(MoveType, &'mv MoveUntypedReference),
        // todo
    }

    pub unsafe fn borrow_move_value_as_rust_value<'mv>(
        type_: &MoveType,
        value: &'mv AnyValue,
    ) -> BorrowedTypedMoveValue<'mv> {
        // todo need to think about the soundness of this transmute
        match type_.type_desc {
            TypeDesc::Bool => BorrowedTypedMoveValue::Bool(mem::transmute(value)),
            TypeDesc::U8 => BorrowedTypedMoveValue::U8(mem::transmute(value)),
            TypeDesc::U64 => BorrowedTypedMoveValue::U64(mem::transmute(value)),
            TypeDesc::U128 => BorrowedTypedMoveValue::U128(mem::transmute(value)),
            TypeDesc::Address => BorrowedTypedMoveValue::Address(mem::transmute(value)),
            TypeDesc::Signer => BorrowedTypedMoveValue::Signer(mem::transmute(value)),
            TypeDesc::Vector => {
                let element_type = *type_.type_info.vector.element_type;
                let move_ref = mem::transmute(value);
                BorrowedTypedMoveValue::Vector(element_type, move_ref)
            }
            TypeDesc::Struct => {
                let struct_info = type_.type_info.struct_;
                BorrowedTypedMoveValue::Struct(struct_info, value)
            }
            TypeDesc::Reference => {
                let element_type = *type_.type_info.reference.element_type;
                let move_ref = mem::transmute(value);
                BorrowedTypedMoveValue::Reference(element_type, move_ref)
            }
        }
    }

    pub enum TypedMoveBorrowedRustVec<'mv> {
        Bool(MoveBorrowedRustVec<'mv, bool>),
        U8(MoveBorrowedRustVec<'mv, u8>),
        U64(MoveBorrowedRustVec<'mv, u64>),
        U128(MoveBorrowedRustVec<'mv, u128>),
        Address(MoveBorrowedRustVec<'mv, MoveAddress>),
        Signer(MoveBorrowedRustVec<'mv, MoveSigner>),
        Vector(MoveType, MoveBorrowedRustVec<'mv, MoveUntypedVector>),
        Struct(MoveBorrowedRustVecOfStruct<'mv>),
        Reference(MoveType, MoveBorrowedRustVec<'mv, MoveUntypedReference>),
        // todo
    }

    #[derive(Debug)]
    pub enum TypedMoveBorrowedRustVecMut<'mv> {
        Bool(MoveBorrowedRustVecMut<'mv, bool>),
        U8(MoveBorrowedRustVecMut<'mv, u8>),
        U64(MoveBorrowedRustVecMut<'mv, u64>),
        U128(MoveBorrowedRustVecMut<'mv, u128>),
        Address(MoveBorrowedRustVecMut<'mv, MoveAddress>),
        Signer(MoveBorrowedRustVecMut<'mv, MoveSigner>),
        Vector(MoveType, MoveBorrowedRustVecMut<'mv, MoveUntypedVector>),
        Struct(MoveBorrowedRustVecOfStructMut<'mv>),
        Reference(MoveType, MoveBorrowedRustVecMut<'mv, MoveUntypedReference>),
        // todo
    }

    #[rustfmt::skip]
    pub unsafe fn borrow_typed_move_vec_as_rust_vec<'mv>(
        type_: &'mv MoveType,
        mv: &'mv MoveUntypedVector,
    ) -> TypedMoveBorrowedRustVec<'mv> {
        match type_.type_desc {
            TypeDesc::Bool => {
                TypedMoveBorrowedRustVec::Bool(borrow_move_vec_as_rust_vec::<bool>(mv))
            }
            TypeDesc::U8 => {
                TypedMoveBorrowedRustVec::U8(borrow_move_vec_as_rust_vec::<u8>(mv))
            }
            TypeDesc::U64 => {
                TypedMoveBorrowedRustVec::U64(borrow_move_vec_as_rust_vec::<u64>(mv))
            }
            TypeDesc::U128 => {
                TypedMoveBorrowedRustVec::U128(borrow_move_vec_as_rust_vec::<u128>(mv))
            }
            TypeDesc::Address => {
                TypedMoveBorrowedRustVec::Address(borrow_move_vec_as_rust_vec::<MoveAddress>(mv))
            }
            TypeDesc::Signer => {
                TypedMoveBorrowedRustVec::Signer(borrow_move_vec_as_rust_vec::<MoveSigner>(mv))
            }
            TypeDesc::Vector => {
                TypedMoveBorrowedRustVec::Vector(
                    *type_.type_info.vector.element_type,
                    borrow_move_vec_as_rust_vec::<MoveUntypedVector>(mv),
                )
            }
            TypeDesc::Struct => {
                TypedMoveBorrowedRustVec::Struct(
                    MoveBorrowedRustVecOfStruct {
                        inner: mv,
                        name: type_.name,
                        type_: &type_.type_info.struct_,
                    }
                )
            }
            TypeDesc::Reference => {
                TypedMoveBorrowedRustVec::Reference(
                    *type_.type_info.reference.element_type,
                    borrow_move_vec_as_rust_vec::<MoveUntypedReference>(mv),
                )
            }
        }
    }

    #[rustfmt::skip]
    pub unsafe fn borrow_typed_move_vec_as_rust_vec_mut<'mv>(
        type_: &'mv MoveType,
        mv: &'mv mut MoveUntypedVector,
    ) -> TypedMoveBorrowedRustVecMut<'mv> {
        match type_.type_desc {
            TypeDesc::Bool => {
                TypedMoveBorrowedRustVecMut::Bool(borrow_move_vec_as_rust_vec_mut::<bool>(mv))
            }
            TypeDesc::U8 => {
                TypedMoveBorrowedRustVecMut::U8(borrow_move_vec_as_rust_vec_mut::<u8>(mv))
            }
            TypeDesc::U64 => {
                TypedMoveBorrowedRustVecMut::U64(borrow_move_vec_as_rust_vec_mut::<u64>(mv))
            }
            TypeDesc::U128 => {
                TypedMoveBorrowedRustVecMut::U128(borrow_move_vec_as_rust_vec_mut::<u128>(mv))
            }
            TypeDesc::Address => {
                TypedMoveBorrowedRustVecMut::Address(borrow_move_vec_as_rust_vec_mut::<MoveAddress>(mv))
            }
            TypeDesc::Signer => {
                TypedMoveBorrowedRustVecMut::Signer(borrow_move_vec_as_rust_vec_mut::<MoveSigner>(mv))
            }
            TypeDesc::Vector => {
                TypedMoveBorrowedRustVecMut::Vector(
                    *type_.type_info.vector.element_type,
                    borrow_move_vec_as_rust_vec_mut::<MoveUntypedVector>(mv),
                )
            }
            TypeDesc::Struct => {
                TypedMoveBorrowedRustVecMut::Struct(
                    MoveBorrowedRustVecOfStructMut {
                        inner: mv,
                        name: type_.name,
                        type_: &type_.type_info.struct_,
                    }
                )
            }
            TypeDesc::Reference => {
                TypedMoveBorrowedRustVecMut::Reference(
                    *type_.type_info.reference.element_type,
                    borrow_move_vec_as_rust_vec_mut::<MoveUntypedReference>(mv),
                )
            }
        }
    }

    pub unsafe fn walk_struct_fields<'mv>(
        info: &'mv StructTypeInfo,
        struct_ref: &'mv AnyValue,
    ) -> impl Iterator<Item = (&'mv MoveType, &'mv AnyValue)> {
        let field_len = usize::try_from(info.field_array_len).expect("overflow");
        let fields: &'mv [StructFieldInfo] = slice::from_raw_parts(info.field_array_ptr, field_len);

        fields.iter().map(|field| {
            let struct_base_ptr: *const AnyValue = struct_ref as _;
            let field_offset = isize::try_from(field.offset).expect("overflow");
            let field_ptr = struct_base_ptr.offset(field_offset);
            let field_ref: &'mv AnyValue = &*field_ptr;
            (&field.type_, field_ref)
        })
    }

    /// # References
    ///
    /// - `move-vm-types::values::Value`
    /// - `move-core-types::value`
    impl<'mv> serde::Serialize for BorrowedTypedMoveValue<'mv> {
        fn serialize<S: serde::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
            use serde::ser::SerializeSeq;

            match self {
                BorrowedTypedMoveValue::Bool(v) => serializer.serialize_bool(**v),
                BorrowedTypedMoveValue::U8(v) => serializer.serialize_u8(**v),
                BorrowedTypedMoveValue::U64(v) => serializer.serialize_u64(**v),
                BorrowedTypedMoveValue::U128(v) => serializer.serialize_u128(**v),
                BorrowedTypedMoveValue::Address(v) => v.0.serialize(serializer),
                BorrowedTypedMoveValue::Signer(v) => v.0 .0.serialize(serializer),
                BorrowedTypedMoveValue::Vector(mt, mv) => unsafe {
                    let rv = borrow_typed_move_vec_as_rust_vec(mt, mv);
                    rv.serialize(serializer)
                },
                BorrowedTypedMoveValue::Struct(st, mv) => unsafe {
                    // fixme: probably need serialize_struct here
                    let len = usize::try_from(st.field_array_len).expect("overflow");
                    let mut seq = serializer.serialize_seq(Some(len))?;
                    let fields = walk_struct_fields(st, mv);
                    for (type_, ref_) in fields {
                        let rv = borrow_move_value_as_rust_value(type_, ref_);
                        seq.serialize_element(&rv);
                    }
                    seq.end()
                },
                BorrowedTypedMoveValue::Reference(mt, mv) => unsafe {
                    let rv = borrow_move_value_as_rust_value(mt, &*mv.0);
                    rv.serialize(serializer)
                },
            }
        }
    }

    impl<'mv> serde::Serialize for TypedMoveBorrowedRustVec<'mv> {
        fn serialize<S: serde::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
            use serde::ser::SerializeSeq;

            match self {
                TypedMoveBorrowedRustVec::Bool(v) => {
                    let mut seq = serializer.serialize_seq(Some(v.len()))?;
                    for e in v.iter() {
                        seq.serialize_element(e)?;
                    }
                    seq.end()
                }
                TypedMoveBorrowedRustVec::U8(v) => {
                    let mut seq = serializer.serialize_seq(Some(v.len()))?;
                    for e in v.iter() {
                        seq.serialize_element(e)?;
                    }
                    seq.end()
                }
                TypedMoveBorrowedRustVec::U64(v) => {
                    let mut seq = serializer.serialize_seq(Some(v.len()))?;
                    for e in v.iter() {
                        seq.serialize_element(e)?;
                    }
                    seq.end()
                }
                TypedMoveBorrowedRustVec::U128(v) => {
                    let mut seq = serializer.serialize_seq(Some(v.len()))?;
                    for e in v.iter() {
                        seq.serialize_element(e)?;
                    }
                    seq.end()
                }
                TypedMoveBorrowedRustVec::Address(v) => {
                    let mut seq = serializer.serialize_seq(Some(v.len()))?;
                    for e in v.iter() {
                        seq.serialize_element(&e.0)?;
                    }
                    seq.end()
                }
                TypedMoveBorrowedRustVec::Signer(v) => {
                    let mut seq = serializer.serialize_seq(Some(v.len()))?;
                    for e in v.iter() {
                        seq.serialize_element(&e.0 .0)?;
                    }
                    seq.end()
                }
                TypedMoveBorrowedRustVec::Vector(t, v) => {
                    let mut seq = serializer.serialize_seq(Some(v.len()))?;
                    for e in v.iter() {
                        unsafe {
                            let e = borrow_typed_move_vec_as_rust_vec(t, e);
                            seq.serialize_element(&e)?;
                        }
                    }
                    seq.end()
                }
                TypedMoveBorrowedRustVec::Struct(s) => {
                    let len = usize::try_from(s.type_.field_array_len).expect("overflow");
                    let mut seq = serializer.serialize_seq(Some(len))?;
                    unsafe {
                        for vref in s.iter() {
                            let type_ = MoveType {
                                name: s.name,
                                type_desc: TypeDesc::Struct,
                                type_info: TypeInfo { struct_: *s.type_ },
                            };
                            let e = borrow_move_value_as_rust_value(&type_, vref);
                            seq.serialize_element(&e)?;
                        }
                    }
                    seq.end()
                }
                TypedMoveBorrowedRustVec::Reference(t, v) => {
                    let mut seq = serializer.serialize_seq(Some(v.len()))?;
                    for e in v.iter() {
                        unsafe {
                            let e = borrow_move_value_as_rust_value(t, &*e.0);
                            seq.serialize_element(&e)?;
                        }
                    }
                    seq.end()
                }
            }
        }
    }

    impl<'mv> core::fmt::Debug for BorrowedTypedMoveValue<'mv> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            match self {
                BorrowedTypedMoveValue::Bool(v) => v.fmt(f),
                BorrowedTypedMoveValue::U8(v) => v.fmt(f),
                BorrowedTypedMoveValue::U64(v) => v.fmt(f),
                BorrowedTypedMoveValue::U128(v) => v.fmt(f),
                BorrowedTypedMoveValue::Address(v) => v.fmt(f),
                BorrowedTypedMoveValue::Signer(v) => v.fmt(f),
                BorrowedTypedMoveValue::Vector(t, v) => unsafe {
                    let rv = borrow_typed_move_vec_as_rust_vec(t, v);
                    rv.fmt(f)
                },
                BorrowedTypedMoveValue::Struct(t, v) => unsafe {
                    // fixme struct / field names
                    let mut dbg = f.debug_list();
                    let fields = walk_struct_fields(t, v);
                    for (type_, ref_) in fields {
                        let rv = borrow_move_value_as_rust_value(type_, ref_);
                        dbg.entry(&rv);
                    }
                    dbg.finish()
                },
                BorrowedTypedMoveValue::Reference(t, v) => unsafe {
                    let rv = borrow_move_value_as_rust_value(t, &*v.0);
                    rv.fmt(f)
                },
            }
        }
    }

    impl<'mv> core::fmt::Debug for TypedMoveBorrowedRustVec<'mv> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            match self {
                TypedMoveBorrowedRustVec::Bool(v) => v.fmt(f),
                TypedMoveBorrowedRustVec::U8(v) => v.fmt(f),
                TypedMoveBorrowedRustVec::U64(v) => v.fmt(f),
                TypedMoveBorrowedRustVec::U128(v) => v.fmt(f),
                TypedMoveBorrowedRustVec::Address(v) => v.fmt(f),
                TypedMoveBorrowedRustVec::Signer(v) => v.fmt(f),
                TypedMoveBorrowedRustVec::Vector(t, v) => {
                    let mut dbg = f.debug_list();
                    for e in v.iter() {
                        unsafe {
                            let e = borrow_typed_move_vec_as_rust_vec(t, e);
                            dbg.entry(&e);
                        }
                    }
                    dbg.finish()
                }
                TypedMoveBorrowedRustVec::Struct(s) => {
                    let mut dbg = f.debug_list();
                    unsafe {
                        for vref in s.iter() {
                            let type_ = MoveType {
                                name: s.name,
                                type_desc: TypeDesc::Struct,
                                type_info: TypeInfo { struct_: *s.type_ },
                            };
                            let e = borrow_move_value_as_rust_value(&type_, vref);
                            dbg.entry(&e);
                        }
                    }
                    dbg.finish()
                }
                TypedMoveBorrowedRustVec::Reference(t, v) => {
                    let mut dbg = f.debug_list();
                    for e in v.iter() {
                        unsafe {
                            let e = borrow_move_value_as_rust_value(t, &*e.0);
                            dbg.entry(&e);
                        }
                    }
                    dbg.finish()
                }
            }
        }
    }
}

/// Compatibility with the target platform, e.g. Solana.
#[cfg(not(feature = "solana"))]
pub(crate) mod target_defs {
    // Move addresses are 16 bytes by default, but can be made 20 or 32 at compile time.
    pub const ACCOUNT_ADDRESS_LENGTH: usize = 16;

    pub fn print_string(s: &str) {
        todo!()
    }

    pub fn print_stack_trace() {
        todo!()
    }

    pub fn abort(code: u64) -> ! {
        todo!()
    }
}

#[cfg(feature = "solana")]
pub(crate) mod target_defs {
    // Solana pubkeys are 32 bytes.
    // Move addresses are 16 bytes by default, but can be made 20 or 32 at compile time.
    pub const ACCOUNT_ADDRESS_LENGTH: usize = 32;

    pub fn print_string(s: &str) {
        todo!()
    }

    pub fn print_stack_trace() {
        todo!()
    }

    pub fn abort(code: u64) -> ! {
        unsafe {
            syscalls::sol_log_64_(
                code, code, code, code, code,
            );
            syscalls::abort()
        }
    }

    // NB: not using the "static-syscalls" sbf feature
    mod syscalls {
        extern "C" {
            pub fn abort() -> !;
            pub fn sol_log_64_(_: u64, _: u64, _: u64, _: u64, _: u64);
        }
    }

    mod globals {
        use alloc::alloc::{GlobalAlloc, Layout};
        use core::mem::size_of;
        use core::ptr::null_mut;

        const PANIC_ABORT_CODE: u64 = 101;

        #[panic_handler]
        fn panic(info: &core::panic::PanicInfo) -> ! {
            super::abort(PANIC_ABORT_CODE);
        }

        #[global_allocator]
        static A: BumpAllocator = BumpAllocator {
            start: HEAP_START_ADDRESS as usize,
            len: HEAP_LENGTH,
        };

        pub struct BumpAllocator {
            pub start: usize,
            pub len: usize,
        }

        unsafe impl GlobalAlloc for BumpAllocator {
            #[inline]
            unsafe fn alloc(&self, layout: Layout) -> *mut u8 {
                let pos_ptr = self.start as *mut usize;

                let mut pos = *pos_ptr;
                if pos == 0 {
                    // First time, set starting position
                    pos = self.start + self.len;
                }
                pos = pos.saturating_sub(layout.size());
                pos &= !(layout.align().wrapping_sub(1));
                if pos < self.start + size_of::<*mut u8>() {
                    return null_mut();
                }
                *pos_ptr = pos;
                pos as *mut u8
            }
            #[inline]
            unsafe fn dealloc(&self, _: *mut u8, _: Layout) {
                // I'm a bump allocator, I don't free
            }
        }
        pub const HEAP_START_ADDRESS: u64 = 0x300000000;
        pub const HEAP_LENGTH: usize = 32 * 1024;
    }
}

#[cfg(test)]
mod tests;
